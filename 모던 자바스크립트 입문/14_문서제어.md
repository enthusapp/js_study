14.1 DOM 트리
=============
- 문서를 제어하는 API인 DOM
- 문서 객체(`<html>`, `<bocy>`)를 인식하는 방식
- 웹 브라우저가 HTML 페이지를 인식하는 방식

14.1.1 DOM 트리
---------------
- 웹 페이지의 내용은 Document 객체가 관리
- 웹 브라우저가 웹 페이지를 읽어 들이면 렌더링 엔진은 웹 페이지의 HTML 문서 구문을 해석하고 Document 객체에서 문서 내용을 관리하는 DOM 트리라고 하는 객체의 트리 구조를 만든다.
```
<!DOCTYPE html>  
<html lang="ko">
	<head>
		<title>간단한 HTML문서</title>
		<meta charset="UTF-8">
	</head>
	<body>
		<h1>DOM 이란?</h1>
		<p><strong>Document Object Model</strong>의 줄임말입니다.</p>
	</body>
</html>
```
- 노드(Node) : DOM 트리를 구성하는 객체 하나(head, body, title, script, h1 등)
- 문서 노드 : 전체 문서를 가리키는 Document 객체. document로 참조할 수 있다.
- HTML 요소 노드 : HTML 요소를 가리키는 객체(요소 객체)
- 텍스트 노드 : 텍스트를 가리키는 객체(텍스트 객체)
```
p. 513 그림 14-2 DOM 트리
```
- HTML은 요소 뒤에 공백 문자가 여러 개 있어도 무시
- DOM 트리는 요소 앞뒤에서 연속적인 공백 문자를 발견하면 텍스트로 취급하여 텍스트 노드 생성
- 공백 노드 : 공백 문자만으로 구성된 텍스트 노드
- html 요소 안에 있는 첫 공백 문자와 마지막 공백 문자에 대해서는 공백 노드를 생성하지 않는다.
- DOM 트리는 HTML 문서 안의 요소와 텍스트 사이의 포함 관계를 표현(부모-자식 관계)
- A를 B의 부모노드, B를 A의 자식노드 : 노드 A 바로 아래 노드 B가 있을 경우
- 형제 노드 : 같은 부모를 가진 같은 레벨의 노드
- Document 객체는 모든 노드의 조상 노드이며 DOM 트리의 루트

14.1.2 노드 객체의 프로퍼티
------------------------
- 아래 프로퍼티는 DOM 트리의 계층 구조를 정의

- parentNode : 이 노드의 부조 노드를 참조한다. Document 객체의 부모 노드는 null
- childNodes : 이 노드의 자식 노드의 참조를 저장한 유사 배열 객체(NodeList)
- firstChild : 이 노드의 첫 번째 자식 노드, 자식 노드가 없을 때는 null
- lastChild : 이 노드의 마지막 자식 노드, 자식 노드가 없을 때는 null
- nextSibling : 이 노드와 같은 부모 노드를 가진 이 노드 다음의 형제 노드 
- priviousSibling : 이 노드와 같은 부모 노드를 가진 이 노드 이전의 형제 노드 
- nodeType : 노드 유형을 뜻하는 숫자(1 : 요소 노드. 3 : 텍스트 노드, 9 : Document)
- nodeValue : 텍스트 노드의 텍스트 콘텐츠, 요소 노드에서는 null
- nodeName :  요소 노드는 대문자로 바뀐 요소, 텍스트 노드는 "#text"

- 노드가 가진 이러한 프로퍼티를 활용하면 Document 객체를 타고 내려가 특정 요소 객체나 텍스트 객체를 참조 가능
```
document.childNodes[0].childNodes[2] // body요소
document.firstChild.lastChild  // body 요소
```
- 위 예시는 요소와 요소 사이에 있는 공백 문자의 영향을 받으므로 줄 바꿈 문자와 탭 문자를 제거하면 body 요소 객체의 참조방법을 바꿔야하기 때문 다루기 불편

- DOM 트리 안의 텍스트 노드를 무시하고 HTML 문서에서 요소의 계층 구조만 가져오기 위한 프로퍼티(단, IE8 이전의 인터넷 익스플로러는 지원하지 않음)

- childNodes : 이 요소의 자식 요소 참조를 저장한 유사 배열 객체(NodeList)
- parentElement : 이 요소의 부모 요소 객체를 참조
- firstElementChild : 이 요소의 첫 번째 자식 요소 객체를 참조
- lastElementChild : 이 요소의 마지막 자식 요소 객체를 참조
- nextElementSibling : 이 요소와 같은 부모를 가진 이 요소 다음의 형제 요소 객체를 참조
- priviousElementSibling : 이 요소와 같은 부모를 가진 이 요소 이전의 형제 요소 객체를 참조
- childElementCount : 자식 요소의 개수 (=children.length)  
```
document.children[0].children[1]
document.firstElementChild.lastElementChild
//<body>.../body>
```

- 주요 노드 객체
- 주석(변수 사이의 관계) 노드, 속성 노드
```
p.516 표14-3 주요 노드 객체
```
```
console.log(document.constructor);  //-> HTMLDocument() {...}
console.log(document.nodeName, document.nodeValue, document.nodeType); //-> #document null 9
var element = document.children[0].children[1].firstElementChild;
console.log(element.constructor); // -> HTMLHeadingElement() {...}
console.log(element.nodeName, element.nodeValue, element.nodeType); 
//-> H1 null 1
```

14.1.3 자바스크립트로 웹 페이지 제어하기
------------------------------
- 자바스크립트를 사용하면 DOM 트리의 노드 객체를 가져와서 제어할 수 있다.
- 자바스크립트로 스타일 규칙을 가져와서 제어할 수도 있다.
- 렌더링 엔진은 DOM 트리와 스타일 규칙이 바뀔 때마다 렌더 트리를 다시 구성해서 웹페이지를 다시 그린다.
- 웹 페이지를 사용자가 조작하거나 자바스크립트 코드로 DOM 트리나 스타일을 수정하면 렌더링 엔진은 그때마다 화면을 다시 렌더링 한다.
- 렌더 트리를 다시 구성하고 다시 렌더링 하는 처리는 일반적으로 시간이 많이 걸리는 작업
- 웹 브라우저는 이러한 상황을 피하기 위해 렌더링 처리 횟수를 가능한 줄이는 최적화 처리를 한다.
- 예를 들어 스타일의 수정 요청이 여러 번 반복되면 요청을 대기열에 모아두고 마지막에 한꺼번에 처리

14.2 노드 객체 가져오기
=====================
- 자바스크립트로 HTML 요소를 제어하려면 그 전에 제어하고자 하는 요소 객체를 먼저 가져와야 한다.

14.2.1 id 속성으로 노드 가져오기
----------------------------
- id 속성 값은 유일한 값으로 요소 하나를 가리킴
- getElementById 메서드를 사용
```
 document.getElementById(id 값);
```
```
/* id가 "second"인 요소 객체를 가져와서 그 요소의 내용을 바꾸는 예제*/

<!DOCTYPE html>
<html lang="ko">
    <head>
        <meta charset="UTF-8">
    </head>
    <body>
        <div id="first">첫 번째 div</div>  // div : 박스 또는 레이어, 레이아웃을 만드는 데 자주 사용
        <div id="second">두 번째 div</div>
        <div id="third">세 번째 div</div>
        <script>
            var element = document.getElementById("second");
            element.innerHTML = "여기를 수정함"; // 두 번째 div 요소의 내용을 수정한다. (innerHTML : 특정 요소의 내용을 가져오거나, 특정 요소의 내용을 변경)
        </script>
    </body>
</html>
```

14.2.2 요소의 이름으로 노드 가져오기
--------------
- getElementsByTagName 메서드를 사용하면 인수로 넘긴 문자열과 같은 이름을 가진 태그 목록을 가져올 수 있다.
- 인수로는 태그 이름을 넘김
- 태그 이름은 대소문자를 구별하지 않음
```
document. getElementsByTagName(요소의 태그 이름);
```
```
/* 문서 안의 모드 div요소를 가리키는 요소 객체의 목록 가져오기 */
<!DOCTYPE html>
<html lang="ko">
    <head>
        <meta charset="UTF-8">
    </head>
    <body>
        <div>첫 번째 div</div>
        <div>두 번째 div</div>
        <div>세 번째 div</div>
        <script>
            var elements = document.getElementsByTagName("div"); 
            elements[2].innerHTML = "여기를 수정함"; // 세 번째 div 요소의 내용을 수정한다.
        </script>
    </body>
</html>
```
- elements 복수형 인 이유 : 일반적인 HTML 문서에서는 이름이 같은 태그가 많이 사용되기 때문에
- getElementsByTagName 메서드는 NodeList 객체를 반환
- NodeList 객체는 유사 배열 객체이며 읽기 전용
- 요소 이름 대신 와일드카드(*)를 지정할 수 있다. 이 경우에는 NodeList 에 ㅗ씌 문서 안의 모든 요소를 담아서 반환
```
var allElements = document.getElementsByTagName("*");
```

- getElementsByTagName 메서드는 요소 객체에서도 사용 가능
- getElementsByTagName 메서드가 NodeList에 그 요소의 자식 요소 중에서 인수로 지정한 문자열과 태그 이름이 같은 요소 객체를 담아서 반환
```
/* HTML 문서 안의 첫 번째 div 요소 아래 포함된 모든 p 요소의 목록을 가져오기 */
<!DOCTYPE html>
<html lang="ko">
    <head>
        <meta charset="UTF-8">
    </head>
    <body>
        <div>
            <p class="important">Document Object Model</p>의 줄임말입니다.
        </div>
        <script>
            var divs = document.getElementsByTagName("div");
            var firstDivParas = divs[0].getElementsByTagName("p");
            console.log(firstDivParas);
        </script>
    </body>
</html>
```

Note. NodeList 객체
-------------------
- get ElementsByTagName, getElementsByName, getElementsByClassName 메서드는 NodeList 객체를 반환, 이는 length 프로퍼티를 가진 유사 배열 객체 이며 for 문 등을 사용해서 순회 가능
- NodeList 객체는 HTML 문서의 변화에 따라 동적으로 바뀌기 때문에 var staticList = Array.prototype.slice.call(divs, 0); 같은 방법으로 NodeList 객체의 정적 복사본을 만들어 순회해야함

14.2.3 class 속성 값으로 노드 가져오기
---------------------------
- class 속성 값은 0개 이상의 식별자(클래스 이름)를 CSS에서 사용하는 공백 문자(공백, 탭 등)로 연결한 문자열로 표기
- class 속성으로 class 속성 값을 갖는 요소의 집합이 정의
- 똑같은 식별자를 class 속성 값으로 포함한 요소들이 모인 집합 하나가 정의됨
- getElementsByClassName 메서드를 사용하면 특정 class 속성 값을 class 속성 값으로 가지는 요소 객체 목록을 가져올 수 있고 인수로는 class 속성 값인 식별자를 넘김
```
document.getElementsByClassName(class의_이름);
```
```

<!DOCTYPE html>
<html lang="ko">
    <head>
        <meta charset="utf-8">
    </head>
    <body>
        <div class="cat black">봄베이</div>
        <div class="cat white">페르시안</div>
        <div class="dog white">스피츠</div>
        <script>
            var cats = document.getElementsByClassName("cat");
            for(var i=0; i<cats.length; i++) {
                console.log(i + " 번째 고양이 :  " + cats[i].innerHTML);
            }
        </script>
    </body>
</html>
// ->
// 0 번째 고양이 : 봄베이
// 1 번째 고양이 : 페르시안
```

- 식별자 여러 개를 공백 문자로 연결한 문자열을 인수로 넘기면, 그 식별자들을 class 속성 값으로 갖는 요소의 목록을 가져올 수 있다.
```
var whiteCats = document.gerElementsByClassName("white cat");
```
- getElementsByClassName 메서드는 요소 객체에서도 사용할 수 있다.
- getElementsByClassName 메서드가 그 요소의 자식 요소 중에서 인수로 지정한 문자열을 class 속성 값으로 가지는 요소 객체를 NodeList에 담아서 반환

```
<!DOCTYPE html>
<html lang="ko">
    <head>
        <meta charset="UTF-8">
    </head>
    <body>
        <p>
            <strong class="important">Document Object Model</strong>의 줄임말입니다.
        </p>
        <script>
            var paras = document.getElementsByTagName("p");
            var firstParaImportants = paras[0].getElementsByClassName("important");
            console.log(firstParaImportants);
        </script>
    </body>
</html>
```

14.2.4 name 속성 값으로 노드 가져오기
------------------------------
- name 속성을 그 요소 이름을 지정할 때 사용하며 form과 input 요소 등의 폼 컨트롤 요소, iframe, img, map, object 요소 등에 지정할 수 있음
- name 속성 값은 class 속성 값과 마찬가지로 요소 여러 개를 대상으로 같은 값(이름)을 사용 할 수 있음
```
document.getElementsByName(name 속성 값);
```
```
<!DOCTYPE html>
<html lang="ko">
    <head>
        <meta charset="UTF-8">
    </head>
    <body>
        <form> // 입력값을 받는 영역을 지정한다. 한 페이지에 여러 개가 들어갈 수는 있지만, 영역 안에 영역이 들어가는 것은 불가능하다.
            <input type="checkbox" name="dog" value="pome">포메라니안<br>
            <input type="checkbox" name="dog" value="dalma">달마시안<br>
            <input type="checkbox" name="dog" value="bool">불독<br>
        </form>
        <script>
            var dogs = document.getElementsByName("dog");
            dogs[1].value = "corgi";
            dogs[1].nextSibling.nodeValue = "웰시 코기"; // 이 노드와 같은 부모 노드를 가진 이 노드 다음의 형제 노드.노드의 값
            for(var i=0; i<dogs.length; i++) {
                console.log(i + " 번째의 값 :  " + dogs[i].value);
            }
        </script>
    </body>
</html>
// ->
// -> 0 번째의 값 : pome
// -> 1 번째의 값 : corgi
// -> 2 번째의 값 : bool
```

14.2.5 CSS 선택자로 노드 가져오기
----------------------
- CSS 선택자는 요소를 가리키기 위한 조건을 제공
- 선택자의 조건을 만족하는 요소를 가리켜서 선택자와 일치하는 요소라고 한다.
```
/* class 속성 값이 "subtitle"인 p요소와 일치시키는 선택자 */
p.subtitle // 클래스 선택자 : 특정 클래스 이름을 포함하는 요소
```
```
/* CSS 선택자 */
h1  // 유형 선택자 :지정한 요소 이름을 가진 요소
*  // 전체 선택자 : 모든 요소
#title  // id 선택자 : id 속성 값을 가진 요소
h1[title]  // 속성 선택자 : 속성을 가진 요소
h1[class="maintitle"]  // 속성 선택자 : 지정한 속성 값을 가진 요소
input:checked // 선택된 라디오 버튼이나 선택된 체크 박스 요소
h1:hover  // 마우스 포인터 아래에 있는 h1 요소
#title span  // id 속성 값이 title인 요소의 자손 요소로 존재하는 span 요소
#title > span  // id 속성 값이 title인 요소의 직계 자식 요소로 존재하는 span 요소
body>h1:first-child  // body 요소의 첫 번째 h1 요소
p, #title  // p 요소와 id 송성 값이 title인 요소
```

- querySelectorAll 메서드를 사용해서 인수로 넘긴 선택자와 일치하는 요소 객체가 담긴 NodeList를 가져올 수 있다.
```
document.querySelectorAll("선택자");
```
- querySelectorAll 메서드가 반환하는 NodeList는 ‘살아 있는 상태’가 아니라 NodeList에 포함된 요소는 메서드를 호출한 시점에 일치한 요소
- querySelectorAll 메서드는 일치한 요소가 없을 때 빈 NodeList를 반환
```
var elements = document.querySelectorAll("p.subtitle>span"); // class 속성 값이 subtitle인 p요소의 직계 자식 요소인 span 요소가 담긴 NodeList를 반환
```

- querySelector  메서드는 지정한 선택자와 일치하는 요소 객체 중에서 문서 위치가 첫 번째인 요소 객체를 반환
```
document.querySelector("선택자“);
```
```
var element = document.querySelector("p.subtitle>span"); // class 속성 값이 subtitle인 p요소의 직계 자식 요소 중 첫 번째 span 요소를 반환
```
- querySelector, querySelectorAll 메서드는 요소 객체에서도 사용 가능
- querySelector, querySelectorAll 메서드는  :first-line(요소의 첫 번째 줄을 선택하는 가상요소), :first-letter(요소의 첫번째 문자를 선택하는 가상요소), :link, :visitesd 등의 의사 선택자를 지원하지 않는다.


14.2.6 Document 객체의 프로퍼티
-----------------------
- W3C에서 DOM을 표준화 하기 이전의 DOM을 가리켜 DOM Level 0 이라고 한다.
- DOM Level 0에는 앞서 설명한 노드를 가져오는 메서드가 없는 대신 특정 요소 객체를 읽고 쓰느느 수단이 Document 객체의 프로퍼티로 마련
- 이들 프로퍼티는 DOM의 최신 버전(DOM Level 3)에도 남아 있으며 주요 브라우저에서 사용 가능
```
p.527 요소를 읽고 쓰기 위해 마련된 Document 객체의 프로퍼티
```

14.3 속성 값의 읽기와 쓰기
=====================
- 요소의 속성 값은 요소 객체의 프로퍼티 또는 요소 객체의 메서드로 읽고 쓸 수 있다.

14.3.1 요소의 속성 값
---------------
- 대부분의 HTML 요소에는 속성을 설정해서 추가적인 정보를 더할 수 있다.
- 이를 활용해서 요소에 다른 요소와 구별되는 특별한 스타일을 입히거나 특별한 기능을 부여가능
```
<a id="school" href="http://school.gitbut.co.kr">길벗스쿨</a>
// a요소에는 id 속성과 href 속성이 설정(속성 이름 = 속성 값)
```

14.3.2 요소 객체의 프로퍼티로 요소의 속성을 읽고 쓰기
--------
- 요소 객체에는 요소의 일반적인 속성을 표현하기 위한 프로퍼티가 정의
- 요소 객체에는 일반적인 HTML 속성(id, class, name, src, hred, ...)과 이벤트 처리기 프로퍼티(onclick, onmousedown, ...)등이 정의
```
요소 객체. 속성 이름
```
```
<!DOCTYPE html>
<html lang="ko">
    <head>
        <meta charset="UTF-8">
    </head>
    <body>
        <a id="school" href="http://school.gilbut.co.kr">길벗스쿨</a>
        <script>
            var anchor = document.getElementById("school");
            console.log(anchor.href);  // → http://school.gilbut.co.kr, 프로퍼티 읽기 가능
        </script>
    </body>
</html>
// ex. anchor.href = "http://school.gilbut.co.kr" 프로퍼티 쓰기 가능, 속성 값 설정
```

- HTML 요소의 속성 이름은 대소문자를 구분하지 않지만 자바 스크립트 요소 객체의 속성 프로퍼티는 대소문자를 구분
- HTML 요소의 속성을 요소 객체의 속성 프로퍼티로 사용할 때는 소문자로 작성
- 속성 이름이 여러 단어로 구성되었다면 두 번째 이후 단어의 첫 글자를 대문자로 표기한 프로퍼티 이름을 사용
```
accept-charser -> acceptCharset  // form 요소에서 사용할 수 있음
accesskety -> accessKey  // 전역 속성(모든 요소에서 사용할 수 있음)
maxlength -> maxLength  // infut 요소와 textrea 요소에서 사용할 수 있음
tabindex -> tabIndex  // 전역 속성(모든 요소에서 사용할 수 있음)
```
- 몇몇 HTML 속성의 이름은 자바스크립트에서 예약어로 사용하고 있는 이름이므로 속성 이름 앞에 html을 덧붙인다.( ex. label 요소의 for 속성을 설정할 때 자바스크립트에서는 htmlFor를 사용)
- class 속성은 특별한 취급을 받으며 자바스크립트에서는 className 프로퍼티 사용

14.3.3 속성 값 가져오기
------------
- 요소 객체의 getAttribute  메서드는 요소의 속성을 가져온다.
- 해당 속성이 없으면 null 또는 빈 문자열 반환
```
요소 객체.getAttribute(속성의 이름)
```
```
/* input 요소의 value 속성 값을 가져와서 그 목록을 출력*/

<!DOCTYPE html>
<html lang="ko">
    <head>
        <meta charset="UTF-8">
    </head>
    <body>
        <form id="favorite">
            <input type="checkbox" name="dog" value="pome">포메라니안<br>
            <input type="checkbox" name="dog" value="dalma">달마시안<br>
            <input type="checkbox" name="dog" value="bool">불독<br>
        </form>
        <script>
            var result = [];
            var fm = document.getElementById("favorite");
            var list = fm.children;
            for(var i=0; i<list.length; i++) {
                if(list[i].nodeName == "INPUT" && list[i].type == "checkbox") {
                    result.push(list[i].getAttribute("value"));  // push() 메서드는 배열의 끝에 하나 이상의 요소를 추가하고, 배열의 새로운 길이를 반환합니다.
/* var animals = ['pigs', 'goats', 'sheep'];
console.log(animals.push('cows'));
// expected output: 4
console.log(animals);
// expected output: Array ["pigs", "goats", "sheep", "cows"]
animals.push('chickens');
console.log(animals);
// expected output: Array ["pigs", "goats", "sheep", "cows", "chickens"] */

                }
            }
            console.log(result.join(",")); // → pome,dalma,bool  //join() 메서드는 배열의 모든 요소를 연결해 하나의 문자열로 만듭니다.
/* var elements = ['Fire', 'Air', 'Water'];
console.log(elements.join());
// expected output: "Fire,Air,Water"
console.log(elements.join(''));
// expected output: "FireAirWater"
console.log(elements.join('-'));
// expected output: "Fire-Air-Water" */
        </script>
    </body>
</html>
```

14.3.4 속성 값 설정하기
-------------
- 요소 객체의 setAttribute 메서드는 요소의 속성을 설정하고 해당하는 속성이 없을 때는 그 속성을 새롭게 추가한 후에 설정
```
요소 객체.setAttribute(속성이름, 속성 값)
```
```
<!DOCTYPE html>
<html lang="ko">
    <head>
        <meta charset="UTF-8">
    </head>
    <body>
        <a id="school" href="http://school.gilbut.co.kr">길벗스쿨</a>
        <script>
            var anchor = document.getElementById("school");
            anchor.setAttribute("href", "http://www.gilbut.co.kr/");
            console.log(anchor);
        </script>
    </body>
</html>
```
- getAttribute와 setAttribute 메서드는 요소 객체의 속성 프로퍼티에 비해 HTML의 일반적인 속성은 물론 모든 속성을 설정 할 수 있고, 속성 이름을 프로그램 실행 중에 동적으로 설정가능

14.3.5 속성이 있는지 확인하기
-----------
- 속성이 있는지 알려주는 논리값 반환
```
요소 객체.hasAttribute(속성 이름)
``

14.3.6 속성 삭제하기
------------
```
요소 객체.removeAttribute(속성 이름)
```

14.3.7 전체 속성의 목록 가져오기
-------------------------
- 요소 객체에는 attributes 프로퍼티가 정의
- 이 프로퍼티는 NameNodeMap 객체로 그 요소에 설정된 모든 속성의 속성 노드 객체가 담겨있다.
- NameNodeMap 객체는 유사 배열 객체이며 읽기 전용
- NameNodeMap 객체의 요소인 속성 노드 객체의 name 프로퍼티에는 속성 이름이 담겨져 있고, value 프로퍼티에는 속성 값이 담겨있다.
```
<!DOCTYPE html>
<html lang="ko">
    <head>
        <meta charset="UTF-8">
    </head>
    <body>
        <p id="controls">
            <input type="button" value="click" onclick="doSomething();">
        </p>
        <script>
            var para = document.getElementById("controls");
            var list = para.firstElementChild.attributes;
            for(var i=0; i<list.length; i++) {
                console.log(list[i].name + ": " + list[i].value);
            }
        </script>
    </body>
    </html>
<!--// type：button-->
<!--// value：click-->
<!--// onclick：doSomething();-->
```
```
/* 위 예제 속성 값으로 가져오기 */
console.log(list["type"].value);  //-> button
console.log(list["value"].value);  //-> click
console.log(list.onclick.value);  //-> doSomething();
```

14.4 HTML 요소의 내용을 읽고 쓰기
==============
- 요소의 내용이란
- 1. 요소 안의 HTML 코드(innerHTML 프로퍼티로 읽고 쓸 수 있다.)
- 2. 요소를 웹 페이지에 표시할 때의 텍스트 정보(textContent와 innerText 프로퍼티를 사용해서 읽고 쓸 수 있다.)
- 3. 요소 객체 안의 노드의 계층 구조
```
<p id="cards">&hearts;하트는 <em>승려</em>라는 뜻입니다.</p>
```

14.4.1 innerHTML 프로퍼티
-------------------
- innerHTML 프로퍼티는 요소 안의 HTML 코드를 가리킨다.
- innerHTML 프로퍼티를 사용해서 요소 안의 코드를 읽거나 쓸 수 있다.
```
/* 위에서 예로 든 p 요소의 innerHTML 프로퍼티 값 출력하기 */

<!DOCTYPE html>
<html lang="ko">
<head>
	<meta charset="UTF-8">
	<script>
		var para = document.getElementById("crads");
		console.log(textContent(para)); // textContent : 프로퍼티는 노드와 그 자손의 텍스트 내용을 표시한다.
	</script>
</head>
<body>
	<h1>하트</h1>
	<p id="cards">&hearts;하트는 <em>승려</em>라는 뜻입니다.</p>
</body>
</html>
<!--// → ♥하트는 <em>승려</em>라는 뜻입니다.-->
```
```
/* inner HTML 프로퍼티로 p 요소의 내용 수정 */

<!DOCTYPE html>
<html lang="ko">
    <head>
        <meta charset="UTF-8">
    </head>
    <body>
        <p id="cards">&hearts;하트는 <em>승려</em>라는 뜻입니다.</p>
        <script>
            var para = document.getElementById("cards");
            para.innerHTML = "&diams;다이아는 <strong>상인</strong>이라는 뜻입니다.";
            console.log(para.innerHTML);
        </script>
    </body>
</html>
<!--// → ♦다이아는 <strong>상인</strong>이라는 뜻입니다.-->
```
- innerHTML 프로퍼티로 HTML 코드를 편집 할 수 있다.
- 이 방법은 코드를 문자열로 다루어야 하므로 복잡한 구조를 가진 코드를 편집할 때는 적합하지 않다.
- innerHTML 프로퍼티는 간단한 내용을 편집하기에 좋음
- 복잡한 구조를 가진 내용을 편집할 때는 DOM 메서드가 적합

14.4.2 textContent와 innerText 프로퍼티
----------------
- textContent 프로퍼티는 요소의 내용을 웹 페이지에 표시했을 때의 텍스트 정보를 표시
- textContent 프로퍼티 값은 지정한 요소의 자식 노드인 모든 텍스트 노드를 연결한 값
```
<!DOCTYPE html>
<html lang="ko">
    <head>
        <meta charset="UTF-8">
    </head>
    <body>
        <p id="cards">&hearts;하트는 <em>승려</em>라는 뜻입니다.</p>
        <script>
            var para = document.getElementById("cards");
            console.log(para.textContent);
        </script>
    </body>
</html>
<!--// → ♥하트는 승려라는 뜻입니다.-->
```

- textContent 프로퍼티에 텍스트를 대입하면 요소의 내용을 텍스트로 변환 가능
```
para.textContent = "&diams;다이아는 <strong>상인</strong>이라는 뜻입니다.";
console.log(para.innerHTML);
//-> &amp;diams;다이아는&It;strong&gt;상인&It;/strong&gt;이라는 뜻입니다.
console.log(para.textContent);
//-> &diams;다이아는<strong>상인</strong>이라는 뜻입니다.
```
- textContent에 텍스트를 대입하면 요소의 내용을 바꿀 수 있다.
- &, <, > 등의 HTML 특수문자가 이스케이프되어 HTML로 표시할 수 있는 문자열로 바뀜
- textContent 프로퍼티는 IE9 이전 버전에서 사용할 수 없다.
- innerHTML 프로퍼티는 파이어폭스를 제외한 주요 브라우저에서 사용 가능
- textContent, textContent 프로퍼티는 거의 같은 일을 하지만 차이점이 있음
- textContent 는 script 요소 안의+ 텍스트를 반환하지만 innerText는 반환하지 않는다.
- textContent는 공백 문자를 그대로 반환하지만 innerText는 남는 공백 문자를 제거
- innerText는 table, tbody, tr 요소 등의 테이블 요소를 수정할 수 없다.
```
/* textContent의 크로스 브라우징(W3C에서 채택된 표준 웹 기술을 적용해 모든 브라우저에 다른 기종의 운용체계나 HTML 렌더링 기술로 웹페이지를 제작하는 방법론이다.) 대책 */
function textContent(element) {
	var content = element.textContent;
	if( content !== undefined ) return content;
	return element.innerText;
}
```

14.5 노드 생성/삽입/삭제하기
==================
- DOM API를 사용하면 노드를 만들어 DOM 트리에 삽입할 수 있으며 노드를 삭제하거나 치환할 수도 있다.

14.5.1 노드 생성하기
------------
- 새로운 요소 노드 객체를 생성할 때는 createElement 메서드 사용
```
var element = document.createElement(요소의 이름);
```
```
/* h1 요소 객체 만들기 */
var headline = document.createElement("h1");

console.log(headline.nodeName);  //-> "H1"
console.log(headline.nodeType);  //-> 1

console.log(headline.parentNode);  //-> null, 이 노드위 부모노드 참조
console.log(headline.childNode);  //-> null 이 노드의 자식 노드의 참조를 저장한 유사 배열 객체
```
- createElement 생성한 노드 객체는 메모리에 생성되어 있을 뿐 문서의 DOM 트리와는 아무런 관계가 없다.
- 새로운 텍스트 노드 객체를 생성할 때는 createTextNode 메서드를 사용
```
var textnode = document.createTextNode(텍스트);
```
```
var newtext = document.createTextNode("We only see what we know.");
```
- createElement 와 마찬가지로 createTextNode로 만든 노드객체도 문서의 DOM 트리와는 아무런 관계가 없다.

```
p.539 표14-5 shem 객체를 생성하는 주요 메서드
```

14.5.2 노드 삽입하기
------------------
- 요소의 마지막에 삽입하기 : appendChild 메서드
- 요소 객체에 appendChild 메서드를 사용하면 인수로 넘긴 노드 객체를 해당 요소의 마지막 노드로 삽입한다.
```
요소 노드.appendChild(삽입할 노드)
```
- appendChild 메서드로 노드 객체를 삽입하면 그 객체가 DOM 트리에 추가되고 DOM 트리의 각 노드에 계층 구조를 정의하는 프로퍼티(parentNode, childNode 등)가 바뀐다.
```
<!DOCTYPE html>
<html lang="ko">
    <head>
        <meta charset="UTF-8">
    </head>
    <body>
        <ul id="doglist">
            <li>포메라니안</li>
            <li>달마시안</li>
        </ul>
    </body>
</html>
// 이 문서의 ul 요소에 마지막 자식 요소로 <li>불독</li>를 삽입하려면 아래 코드 작성
```
```
var doglist = document.gerElementById("doglist");
var element = document.createElement("li");  // li 요소 객체를 생성
var text = document.createTextNode("불독");  // 텍스트 노드 생성
doglist.appendChild(element);  // ul 요소에 element 삽입
element.appendChild(text);  // element에 텍스트 노드 삽입
// doglist.appendChild(element) 와 element.appendChild(text); 순서 변경 가능
```
```
/* 위 코드의 같은 결과 */
var doglist = document.gerElementById("doglist");
var element = document.createElement("li");  // li 요소 객체를 생성
element.textContent = "불독";  // 텍스트 노드 생성
doglist.appendChild(element);  // ul 요소에 element를 삽입
```
- 지정한 자식 노드의 바로 앞에 삽입하기 : insertBefore 메서드
```
요소 노드.insertBegore(삽입할 노드, 자식 노드)
```
```
<!DOCTYPE html>
<html lang="ko">
    <head>
        <meta charset="UTF-8">
    </head>
    <body>
        <ul id="doglist">
            <li>포메라니안</li>
            <li>달마시안</li>
        </ul>
        <script>
            var doglist = document.getElementById("doglist");
            var element = document.createElement("li");
            var text = document.createTextNode("불독");
            doglist.insertBefore(element,doglist.children[1]);  // 두 번째 자식 요소의 바로 앞에 삽입
            element.appendChild(text);
        </script>
    </body>
</html>
```
- 이미 있는 노드를 appendChild와 insertBefore 메서드로 문서에 삽입하면 해당 노드를 현재 위치에서 삭제하고 새로운 위치에 삽입
- 결과적으로는 그 노드는 이동
```
<!DOCTYPE html>
<html lang="ko">
    <head>
        <meta charset="UTF-8">
    </head>
    <body>
        <ul id="doglist">
            <li>포메라니안</li>
            <li>달마시안</li>
        </ul>
        <script>
            var doglist = document.getElementById("doglist");
            doglist.appendChild(doglist.children[0]); // 첫 번째 자식 요소의 가장 끝에 삽입
        </script>
    </body>
</html>
```
- 실제로 요소를 동적으로 생성하는 코드를 보면 요소이름, 속성 이름과 속성 값, 자식 노드 목록 으로 지정하는 코드가 대부분
```
/*-----------------------------------------------------------------------*
 * 함수 이름：elt
 * 주어진 이름(name)과 속성(attributes), 자식 노드를 포함하는 요소를 만들어서 반환하는 함수
 *-----------------------------------------------------------------------*/
function elt(name, attributes) {
	var node = document.createElement(name);
	if( attributes ) {
		for(var attr in attributes) {
			if(attributes.hasOwnProperty(attr)) {
				node.setAttribute(attr,attributes[attr]);
			}
		}
	}
	for(var i=2; i<arguments.length; i++) {
		var child = arguments[i];
		if( typeof child == "string" ) {
			child = document.createTextNode(child);
		}
		node.appendChild(child);
	}
	return node;
}
```
```
/* <h1>DOM에 관하여</h1>*/

<!DOCTYPE html>
<html lang="ko">
	<head>
		<meta charset="UTF-8">
		<title>textContent 함수의 사용법</title>
		<script src="./elt.js"></script>
		<script>
			window.onload = function(){  // 문서가 다 읽어지고 나서(로딩후) 실행시킬 js 소스를 넣으면 실행
				var headline = elt("h1", null, "DOM에 관하여");
				document.body.appendChild(headline); // body 요소 마지막에 노드 삽입 하기
			};
		</script>
	</head>
	<body>
	</body>
</html>
```
```
/* <input type="button" value="click"> */

<!DOCTYPE html>
<html lang="ko">
	<head>
		<meta charset="UTF-8">
		<title>textContent 함수의 사용법</title>
		<script src="./elt.js"></script>
		<script>
			window.onload = function(){
				var input = elt("input", { type: "button", value: "click" });
				document.body.appendChild(input);
			};
		</script>
	</head>
	<body>
	</body>
</html>
```
```
/* select 메뉴 만들기 */

<!DOCTYPE html>
<html lang="ko">
	<head>
		<meta charset="UTP=8">
	</head>
	<body>
		<form id="menu">
			<select name="bloodtype" id="bloodtype"> // selet : 선택목록
				<option>A형</option> // option선택 목록에 들어갈 항목
				<option>B형</option>
				<option>O형</option>
				<option>AB형</option>
			</select>
		</from>
	</bocy>
</html>
```
```
/* elt.js를 사용해서 위 select 메뉴를 body의 자식요소로 만들기 */

<!DOCTYPE html>
<html lang="ko">
<head>
	<meta charset="UTF-8">
	<title>elt 사용 예제</title>
	<script src="./elt.js"></script>
	<script>
		window.onload = function() {
			var bloodtypes = ["A형", "B형", "O형", "AB형"];
			var form = elt("form", {id: "menu"});
			var select = elt("select", {name: "bloddtype", id: "bloodtype"});
			bloodtypes.forEach(function(type) {
				select.appendChild(elt("option", null, type));
			});
			form.appendChild(select);
			document.body.appendChild(form);
		};
	</script>
</head>
<body>
</body>
</html>
```

14.5.3 노드 삭제하기
------------------
```
노드.removeChild(자식 노드) // 해당 노드의 자식 노드만
node.parentNode.removeChild(node); // 특정한 노드인 node를 삭제하고자 할 때
```

14.5.4 노드 치환하기
-------------
```
노드.replaseChild(새로운 노드, 자식 노드) // 해당 노드의 자식 노드만
node.parentNode..replaseChild(newnode, node); // 특정 노드인 node를 새로운 노드인 nenode로 치환하고자 할 때)
```

14.6 HTML 요소의 위치
================

14.6.1 HTML 요소의 위치를 표현하는 좌표계
---------------
```
p.848 그림 14-23 뷰 포트 좌표계와 문서 좌표계
```
### 뷰 포트 좌표계(윈도우 좌표계)
- 뷰 포트의 왼쪽 위 꼭짓점을 원점으로 하는 좌표계
- 웹 브라우저에서 문서의 내용을 표시하는 영역
- 메뉴, 도구 모음, 탭 등을 포함하지 않음

### 문서 좌표계
- 문서의 왼쪽 위 꼭짓점을 원점으로 하는 좌표계
- 문서는 웹 브라우저 표시 영역(뷰 포트)안에 표시
- 문서를 스크롤하면 문서 좌표계의 원점이 뷰 포트를 따라 이동
- 문서 좌표계를 따르는 요소의 좌표는 사용자가 문서를 스크롤해도 바뀌지 않으므로 뷰 포트 좌표계를 따르는 요소보다 다루기 쉽다.

14.6.2 HTML 요소의 위치와 크기 구하기
```
var rec = 요소 객체.getBoundingClientRect(); // 뷰 포트 좌표계로 측정한 해당 요소의 보더 박스위치와 크기 객체를 반환
```
- getBoundingClientRect 메서드는 ClientRect 객체를 반환한다.
```
left :요소 박스의 왼쪽 위 꼭지점의 X좌표
top :요소 박스의 왼쪽 위 꼭지점의 Y좌표
right : 요소 박스의 오른쪽 아래 꼭짓점의 X좌표
bottom : 요소 박스의 오른쪽 아래 꼭짓점의 Y좌표
width : 요소 박스의 너비(IE8은 지원하지 않음)
height : 요소 박스의 높이(IE8은 지원하지 않음)
p.549 그림 14-24 getBoundingClientRect 메서드의 반환값이 갖는 프로퍼티
```

Note. 블록 박스의 박스 모델
- p, h1~6, div 요소 등의 display 속성 값은 block이며 웹 브라우저에서 블록 박스로 표시
- 블록 박스는 내용 영역(콘텐트), 안쪽 여백 영역(패딩), 테두리 영역(보더), 바깥 여백 영역(마진)이라는 네 개의 사각형 영역으로 구성
- getBoundingClientRect 메서드가 반환하는 정보는 테두리 영역을 포함한 안쪽 영역(보더 박스)의 위치와 크기 정보
```
그림 14-25 박스 모델
```

14.6.3 뷰 포트의 크기 가져오기
---------
- doocument.documentElement.clientWidth : 뷰 포트의 너비(스크롤 막대의 너비를 포함하지 않음)
- doocument.documentElement.clientHeight : 뷰 포트의 높이(스크롤 막대의 높이를 포함하지 않음)
- window.innerWidth : 뷰 포트의 너비(스크롤 막대의 너비를 포함, IE9이후)
- window.innerHeigth : 뷰 포트의 높이(스크롤 막대의 높이를 포함, IE9이후)

14.6.4 스크롤한 거리 구하기
------------
### 인터넷 익스플로러, 파이어폭스 (크롬, 사파리, 오페라 에선 항상 0)
- document.documentElement.scrollLeft : X축 방향으로 스크롤한 거리
- document.documentElement.scrollTop : Y축 방향으로 스크롤한 거리

### 크롬, 사파리, 오페라, 엣지, 각 웹 브라우저의 Quirks Mode (익스플로러, 파이어폭스 항상 0)
- document.body.scrollLeft : X축 방향으로 스크롤한 거리
- document.body.scrollTop : Y축 방향으로 스크롤한 거리

### 파이어폭스, 크롬, 사파리, 오페라, 엣지, IE9 이상 (IE8은 지원하지 않는다.)
- window.pageXOffset : X축 방향으로 스크롤한 거리
- window.pageYOffset : Y축 방향으로 스크롤한 거리

- 앞의 모든 프로퍼티 값은 0 이상의 정수

```
/* 스크롤한 거리를 구하는 함수(크로스 브라우징 대응) */

		function getScrollTop() {
			if( window.pageYOffset !== undefined ) {
				return window.pageYOffset;
			} else {
				return document.documentElement.scrollTop || document.body.scrollTop;
			}
		}
		function getScrollLeft() {
			if( window.pageXOffset !== undefined ) {
				return window.pageXOffset;
			} else {
				return document.documentElement.scrollLeft || document.body.scrollLeft;
			}
		}
```
```
x = x + geetScrollLeft();
y = y + getScrollTop();
```
- 스크롤한 거리를 구한 다음에 뷰 포트 좌표(x,y)를 더하면 그 요소의 문서 좌표(X,Y)를 구할 수 있다.

14.6.5 스크롤 하기
---------
- window 객체의 scrillTo 메서드는 문서 좌표 (X,Y)를 인수로 받으며, 뷰 포트 좌표의 원점(표시 영역의 왼쪽 위 모서리)까지 스크롤
```
window.scrollTo(X,Y);
```
```
/* id 속성 값이 “sec3"인 요소를 표시 영역의 왼쪽 위 모서리까지 스크롤 하려면 */

<!DOCTYPE html>
<html lang="ko">
    <head>
        <meta charset="UTF-8">
    </head>
    <style>
        .box {
            display: inline-block;
            padding: 100px;
            margin: 100px;
            margin-left: 0;
            background-color: yellow;
        }
    </style>
    <body>
        <div class="box" id="sec1">#sec1</div>
        <br/>
        <div class="box" id="sec2">#sec2</div>
        <br/>
        <div class="box" id="sec3">#sec3</div>
        <script>
            function getScrollTop() {
                if( window.pageYOffset !== undefined ) {
                    return window.pageYOffset;
                } else {
                    return document.documentElement.scrollTop || document.body.scrollTop;
                }
            }
            function getScrollLeft() {
                if( window.pageXOffset !== undefined ) {
                    return window.pageXOffset;
                } else {
                    return document.documentElement.scrollLeft || document.body.scrollLeft;
                }
            }

            // 크롬을 비롯한 일부 브라우저에서는 스크롤 복원 기능을 꺼야 합니다
            if ('scrollRestoration' in history) {
                history.scrollRestoration = 'manual';
            }
            var element = document.getElementById("sec3");
            var rect = element.getBoundingClientRect();
            scrollTo(rect.left + getScrollLeft(), rect.top + getScrollTop());
        </script>
    </body>
</html>
```
- 스크롤할 거리를 인수로 받아 문서를 그 거리만큼 스크롤 하기
```
window.scrollBy(dx, dy); // 오른쪽으로 dx, 아래쪽으로 dy만큼 스크롤
scrollBy(0, window.innerHeight); // 한 페이지 분량만큼 스크롤
```
```
/* 부드러운 스크롤 */
		function smoothScroll(id,durationTime) { 
// id :요소의 id 속성 값
			var TIME_INTERVAL = 30;
			var element = document.getElementById(id);
			if( !element ) return;
			var ey = element.getBoundingClientRect().top;
			var dy = ey*TIME_INTERVAL/durationTime; 
// durationTime : 스크롤 지속시간(단위는 밀리초)
			var direction = dy>0 ? 1 : -1;
			var timer = setInterval(function() {
				scrollBy(0,dy); ey -= dy;
				if( direction*ey <= 0 ) clearInterval(timer);
			}, TIME_INTERVAL);
		}
```

- 요소가 웹 브라우저의 표시 영역에 들어올 때까지 스크롤
```
요소 객체.scrillIntoView(alignWithTop);
```
- alignWithTop은 선택 사항으로 생략하면 true
- alignWithTop true면 요소가 표시영역의 위쪽 끝에 오도록 스크롤
- alignWithTop false면 요소가 표시 영역의 아래쪽 끝에 오도록 스크롤
```
/* 위 예제의 id 속성 값이 "sec3"인 요소를 표시 영역의 위쪽 끝까지 스크롤 하기*/

var element = document.getElmentById("sec3");
element.scrollIntoView();
```

14.6.6 HTML 요소의 위치 변경과 렌더링 성능
- 이 절에서 다룬 요소의 위치와 크기를 변경하는 작업은 레이아웃 처리를 촉발하는 방아쇠가 되며, 최적화의 대상이 되지 않는다.
- 레이아웃을 처리하려면 부모 요소까지 거슬러 올라가 계산해야 하며, 이는 렌더링 성능을 현저하게 떨어뜨리는 원인


14.7 HTML 폼
===========
- 폼은 사용자로부터 입력을 받는 HTML의 메커니즘

14.7.1 폼
--------
- 온라인 쇼핑몰에서 사용자 정보를 입력할 때
- 검색엔진에 키워드를 입력할 때
- 데이터베이스를 검색할 때
- 1. 폼에 입력한 데이터를 웹 서버로 보내고 웹 서버는 그 데이터를 처리한다. 그 결과 사용자에게 반환하거나 데이터베이스에 저장한다.
- 2. 클라이언트 측 자바스크립트로 웹 애플리케이션을 만들 때 사용자가 입력을 받은 사용자 인터페이스로 사용한다. 이때 데이터 처리는 클라이언트 측 자바스크립트 프로그램이 담당한다.

14.7.2 폼 요소와 폼 컨트롤 요소
---------------------
- 1. 웹 서버에 데이터를 보낼 때는 우선 form 요소를 작성하고 method와 action 속성을 지정
- 2. form 요소 안에 사용자로 부터 입력을 받는 input 요소 등의 폼 컨트롤 요소를 배치
- 3. 마지막으로 form 요소 안에 데이터를 전송하기 위한 submit 버튼과 데이터 입력을 취소하는 reset 버튼을 배치
- method 속성 : 데이터 전송 방법("POST" 또는 "GET")
- action 속성  : 데이터를 처리하는 CGI 프로그램의 URL

```
<!DOCTYPE html>
<html lang="ko">
<head>
	<meta charset="UTF-8">
	<title>간단한 폼 예제</title>
</head>
<body>
	<form method="post" action="./cgi-bin/post.cgi" name="questions" id="form1">
		<h1>설문 조사</h1>
		<p>
			<label>이름 : </label>
			<input type="text" name="name">
//type 속성 값이 "text"인 input 요소
		</p><p>
			<label>성별 : </label>
			<label><input type="radio" name="sex" value="male">남</label> 
			<label><input type="radio" name="sex" value="female">여</label> 
//성별을 선택하는 라디오 버튼을 type 속성 값이 "radio"인 input 요소
		</p><p>
			<label>혈액형 : </label>
			<select name="bloodtype" id="menu1"> 
//혈액형을 메뉴에서 선택하는 드롭다운 메뉴인 select 요소
				<option>A형</option>
				<option>B형</option>
				<option>O형</option>
				<option>AB형</option>
			</select>
		<p></p>
			<h2>의견</h2>
			<textarea name="opinion" rows="6" cols="80" placeholder="의견을 남겨주세요"></textarea>
//의견 입력란을 textrea 요소
		</p><p>
			<input type="submit" value="보내기"> //데이터 전송
			<input type="reset" value="취소"> //데이터 입력 취소
		</p>
	</form>
</body>
</html>
```
- 폼 요소를 웹 애플리케이션의 사용자 인터페이스로 사용할 때는 form 요소와 submit 버튼이 필요 없으며 인터페이스를 폼 컨트롤만으로 정의할 수 있다.

14.7.3 폼 요소와 폼 컨트롤 요소 가져오기
------------------------
- DOM 메서드로 가져오는 방법
```
var menu = dicumentById("menu1")
var options = menu.getElementsByTagName("option");
var inputs = document.querySelectorAll("#form1 input[type='radio']");
// 성별 정보를 구하는 라디오 버튼 목록 가져오기, querySelectorAll :인수로 넘긴 선택자와 일치하는 요소 객체가 담긴 NodeList

- forms 프로퍼티로 form 요소 가져오기
- form 요소를 문서에 동적으로 추가하면 이 인덱스가 다른 요소를 가리키게 될 가능성이 있기 때문에 사용하지 않는 편이 좋다.
```
document.forms[0] //인덱스로 가져오기
document.forms.form1  //id 속성 값으로 가져오기
document.forms.questions  //name 속성 값으로 가져오기
document.questions //name 속성 값이 "questions"인 form 요소의 목록
```

- form 요소 객체의 자식 요소 객체 가져오기
- form 요소 객체 자체도 유사 배열 객체이며, 해당 폼의 자식 요소인 폼 컨트롤 요소 객체를 배열의 요소로 가지고 있다.
```
//혈액형 메뉴를 정의한 select 요소 객체 가져오기
document.forms.form1[3] 
document.forms.form1.bloodtype
document.forms.form1.menu1
```
- form 요소 객체는 elements 프로퍼티도 가지고 있고 유사 배열 객체이며, 해당 폼의 자식 요소인 폼 컨트롤 요소 객체를 배열의 요소로 가지고 있다.
- 배열의 요소는 HTMLCollection 객체와 마찬가지로 배열 요소의 인덱스, id 속성 값, name 속성 값으로 가져올 수 있다.
```
//혈액형 메뉴를 정의한 select 요소 객체 가져오기
document.forms.form1.elements[3] 
document.forms.form1.bloodtype //name 속성 값이 가리키는 요소가 하나일 때는 그 폼 컨트롤 요소 객체 자체를 반환하고, 여러 개일 때는 그 요소들을 담은 유사 배열 객체를 반환
document.forms.form1.elements.menu1
```
```
var inputs = document.forms.form1.elements.sex;
//input에는 성별을 선택하는 두 개의 input 요소가 담긴 유사 배열 객체의 참조가 들어온다.
var sex_selected;
for(var i=0; i<inputs.length; i++){
	if(inputs[i].checked) sex_selected = inputs[i].value;
} //사용자가 선택한 성별(input 요소의 value 속성 값)을 가져온다.
```

14.8 CSS 제어하기
==========

14.8.1 CSS
--------------
- Cascading Style Sheet
- HTML의 표준 스타일
- 요소의 박스 스타일(너비, 높이, 바깥 여백 영역, 테두리 영역, 배경 등)과 위치를 설정할 수 있다.
- 글꼴 색과 종류 등 다양한 스타일을 지정하여 HTML 문서를 꾸밀 수 있다.

14.8.2 스타일 변경 방법
---------------
- 요소 객체의 style 속성 값을 수정하는 방법
- 스타일 시트에 스타일 클래스로 설정해 둔 다음 요소의 class 속성 값을 바꾸어 스타일을 전환하는 방법
- 스타일 시트를 수정하는 방법(사용 빈도가 높지 않음)

14.8.3 인라인 스타일 제어하기
-------------------
- 요소 객체는 style 프로퍼티를 가지고 있으므로 style 프로퍼티를 사용해서 개별 요소의 스타일을 제어할 수 있다.
```
요소 객체.style.프로퍼티 이름 = 값;
```
- 값은 문자열
```
<!DOCTYPE html>
<html lang = "ko">
	<head>
		<meta charset="UTP-8">
	</head>
	<body>
		<h1 id="title">JavaScript</h1>
	</body>
</html>
```
```
// 위 요소를 마우스로 클릭했을 때 배경을 분홍색으로 바꾸려면
<!DOCTYPE html>
<html lang="ko">
    <head>
        <meta charset="UTF-8">
    </head>
    <body>
        <h1 id="title">JavaScript</h1>
        <script>
            var element = document.getElementById("title");
            element.onclick = function() {
                element.style.backgroundColor = "pink";
            };
        </script>
    </body>
</html>
```
- 요소는 객체가 가진 style 프로퍼티 값은 CSSStyleDeclaration 객체
- CSSStyleDeclaration 객체는 CSS의 다양한 스타일과 대응하는 프로퍼티를 가지고 있으며, 이 프로퍼티 값을 바꾸면 요소 스타일을 바꿀 수 있다.
- CSSStyleDeclaration 의 법칙 : CSS의 프로퍼티 이름에 하이픈(-)이 없으면 그 이름을 그대로 사용, CSS의 프로퍼티 이름에 하이픈이 있으면 하이픈을 제거하고 뒤 단어의 첫 글자를 대문잘 바꾼 문자열을 사용, 단 CSS의 프로퍼티 이름 앞에 하이픈이 있으면 하이픈을 삭제하고 그 뒤에 이어지는 단어를 소문자로 표기
```
fond-size -> fontSize
background-color -> backgroundColor
-webkit-transform -> webkitTransform
단 float 프로퍼티만 cssFloat
```
```
/* 아이콘 편집기 */

<!DOCTYPE html>
<html lang="ko">
<head>
	<meta charset="UTF-8">
	<title>ICON EDITOR</title>
	<script src="./elt.js"></script>
	<script>
		window.onload = function() {
			createIconEditor(document.body,16,16);
		};
		function createIconEditor(parent,nx,ny) {
            // color 선택
			var color = elt("input", {type: "color"});
            // 모두 삭제 버튼
			var clear = elt("input", {type: "button", value: "모두 삭제"});
			clear.onclick = function(e) {
				cells.forEach(function(td){ td.style.backgroundColor = "white"; });
			};
            // 편집기 화면 테이블
			var table = elt("table");
			table.style.borderCollapse = "collapse";
			table.style.marginTop = "5px";
			var cells = []; // td요소를 저장하는 배열
			for(var j=0; j<ny; j++) {
				var tr = elt("tr");
				table.appendChild(tr);
				for(var i=0; i<nx; i++) {
					var td = elt("td");
					cells.push(td);
					td.style.width  = td.style.height = "15px";
					td.style.border = "1px solid gray";
					tr.appendChild(td);
                    // 셀 하나를 클릭할 때 동작하는 이벤트 처리기
					td.onclick = function changeColor(e) {
						e.target.style.backgroundColor = color.value;
					};
				}
			}
            // parent에 각각의 요소를 삽입
			parent.appendChild(color);
			parent.appendChild(clear);
			parent.appendChild(table);
		}
	</script>
</head>
<body>
</body>
</html>
```
- 요소를 생성하면서 동시에 스타일을 설정하며 이벤트 처리기의 설정도 병행
- 이런 방법을 사용하면 나중에 getElementById 메서드 등을 사용하여 요소 객체를 가져올 필요가 없기 때문에 작성해야 하는 코드 양이 줄어든다.
- 요소 생성, 스타일 설정, 이벤트 핸들러 설정을 한곳에서 처리할 수 있어 소스 코드를 알아보기도 쉽다.
- 결과적으로 유지 보수성이 높은 프로그램을 만들 수 있다.
- 그러나 이 방법으로 생성한 요소는 나중에 추가적인 조작을 할 수 없다.
- 조작을 가능하게 하려면 이 예제처럼 생성한 요소 객체를 배열 등(cells)에 별도로 저장

- 요소의 스타일은 스타일 시트 여러 개와 각 요소의 style 속성에 작성한 인라인 스타일에 의해 결정
- 요소의 인라인 스타일은 스타일 요소 객체의 style 프로퍼티로 읽거나 쓸 수 있다.
- 웹 브라우저는 이렇게 다양한 위치에 작성된 스타일 규칙을 취합해서 요소에 적용할 스타일 계산
- 스타일 시트의 설정보다 style 속성에 작성된 값을 우선적으로 적용
- 자바스크립트로 요소의 스타일을 조작할 때는 style 프로퍼티를 사용하는 편이 좋다.

- 계산된 스타일을 style 프로퍼티로 구할 수 없을 때가 있다.(ex. 스타일 시트만으로 스타일을 지정한 요소의 style 객체를 확인해 보면 모든 프로퍼티 값이 빈 문자로 채워져 있음)
- 요소의 계산됭 스타일은 Window 객체의 getComputedStyle 메서드로 가져올 수 있다.
- getComputedStyle  메서드는 style 객체와 마찬가지로 CSSStyleDeclaration 객체를 반환
- CSSStyleDeclaration 객체는 '살아 있는' 상태를 표현
- 그러나 style 객체와 달리 CSSStyleDeclaration 메서드로 가져온 계산된 스타일은 읽기 전용
```
/* 계산된 스타일을 가져오기 */

p{coler : red;}  //style

<p id="note">...</p>  //요소

var element = document.getElementById("note");
console.log(element.style.color);  // -> (빈문자)
console.log(element.style.height);  // -> (빈문자 : 인라인 스타일을 지정하지 않았기 때문)

var computedStyles = getComputedStyle(element);
console.log(ComputedStyle.color);  //-> rgb(255, 0, 0) (절댓값)
console.log(ComputedStyle.height);  //-> 24px (문자열)
```

14.8.4 클래스로 제어 스타일 변경
---------
- 스타일 시트에 정의된 스타일을 요소의 class 속성으로 사용하도록 HTML 문서를 작성해야 한다.
- 자바스크립트로 요소 객체의 className 프로퍼티에 기록된 class 속성 값을 바꾼다.
- 요소의 class 속성 값을 바꾸면 그 요소에 적용되는 스타일도 바뀐다.
- 이 방법을 활용하면 여로 요소의 스타일을 한꺼번에 바꿀 수 있다.
```
/* HTML 문서 */
<!DOCTYPE html>
<html lang="ko">
    <head>
        <meta charset="UTF-8">
    </head>
    <body>
        <h1 id="title">JavaScript</h1>
    </body>
</html>

/* 스타일 시트 */
<!DOCTYPE html>
<html lang="ko">
    <head>
        <meta charset="UTF-8">
        <style>
            .emphasize {
                background-color: pink;
            }
        </style>
    </head>
    <body>
        <h1 id="title">JavaScript</h1>
    </body>
</html>
/* 요소 위에 마우스 포인터가 올라갔을 때 emphasize 스타일 적용 */
<!DOCTYPE html>
<html lang="ko">
    <head>
        <meta charset="UTF-8">
        <style>
            .emphasize {
                background-color: pink;
            }
        </style>
    </head>
    <body>
        <h1 id="title">JavaScript</h1>
        <script>
            var element = document.getElementById("title");
            element.onmouseover = function() {
                element.className = "emphasize";
            };
            element.onmouseout = function() {
                element.className = "";
            }
        </script>
    </body>
</html>
```

- HTML 요소의 class 속성에는 여러 개의 클래스 이름을 공백 문자로 연결해서 지정할 수 있어서 요소가 여러 개의 CSS 클래스에 속하게 된다.
```
<p class="note invisible" id="note1">...</p>
```
- 이때 특정 클래스 이름을 취득/수정/삭제하려면 "note invisible"처럼 여러 개의 클래스 이름을 공백 문자로 연결한 문자열이 들어가 있는 상태이기 때문에 복잡한 문자열 처리를 해야만 한다.
- 이런 상황에서도 사용할 수 있도록 모든 요소 객체에는 classList 프로퍼티가 마련되어 있다.
- classList 속성 값은 DOMTokenList 객체
- DOMTokenList 객체는 유사 배열 객체이며 읽기 전용
- 이 객체는 HTMLCollection객체와 마찬가지로 '살아있는 상태'
- classList 객체의 배열 요소는 className  프로퍼티 값이 항상 반영된 상태
```
<!DOCTYPE html>
<html lang="ko">
    <head>
        <meta charset="UTF-8">
    </head>
    <body>
       <p class="note invisible" id="note1">...</p>
        <script>
            var element = document.getElementById("note1");
            var list = element.classList;
            for(var i=0; i<list.lengthl i++){
            	console.log(list[i]);
            }
            //note, invisible을 순서대로 표시한다
        </script>
    </body>
</html>
```
- DOMTokenList 메서드를 사용하면 class 속성 값을 클래스 이름별로 취득/수정/삭제할 수 있다.
```
add(클래스 이름) : 요소의 클래스 목록에 해당 클래스를 추가한다.
remove(클래스 이름) : 요소의 클래스 목록에 해당 클래스를 삭제한다.
toggle(클래스 이름) : 요소의 클래스 목록에 해당 클래스가 없으면 추가하고 있으면 삭제한다.
constains(클래스 이름) : 요소의 클래스 목록에 해당 클래스가 있는지를 뜻하는 논리값을 반환한다.
```
```
/* 앞 코드의 list에서 클래스 이름 "invisible"을 추가하거나 삭제하기 */

<!DOCTYPE html>
<html lang="ko">
    <head>
        <meta charset="UTF-8">
    </head>
    <body>
       <p class="note invisible" id="note1">...</p>
        <script>
            var element = document.getElementById("note1");
            var list = element.classList;
            list.toggle("invisible");
            console.log("element.className);  //note
            list.toggle("invisible");
            console.log("element.className);  //note invisible
        </script>
    </body>
</html>
```


