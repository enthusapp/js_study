### 5.1 연산자 
ex. +, *

##### 5.1.1 표현식과 연산자
```
a + b
```
- a와 b부분은 연상 대상이 되는 표현식(피연산자)
- 표현식은, 숫자, 문자열, 논리값, 변수, 프로퍼티, 배열 요소, 함수 호출, 메서드호출 이 될 수도 있다.
- 피 연산자의 개수에 따라 단항 연산자, 이항 연산자, 삼항 연산자로 분류
- 삼항 연산자는 ?:(a?b:c = a가 참이면 b로 평가되고 그 밖에는 c로 평가된다.)
- 표현식은 먼저 왼쪽 피연산자 값부터 순서대로 평가되고, 그 다음에 연산자로 계산 시작
- 예외 연산자 : ||, &&, ?:(연산자 먼저 평가)

##### 5.1.2 연산자의 우선순위
- () 안에 들어있는 표현식이 가장 먼저 평가
- * -> +
```
(24/6)*2 //-> 8
24/(6*2)  //-> 2
```

##### 5.1.3 연산자 결합 법칙
- 나눗셈 연산자, 곱셈 연산자는 우선순위는 같지만 왼쪽에서 오른쪽으로 결합
- p. 130 연산자의 우선순위와 결합법칙
```
24/6*2  //-> 8
```

##### 5.1.4 연산자의 부수 효과
```
x=y
```
- 변수 값을 바꾸는 표현식은 일반적으로 부수 효과가 있는 표현식이라고 한다.
- 대입 연산자, 증가 연산자, 감소 연산자, delete


### 5.2 산술 연산
- 사칙연산, 나머지 값, 제곱근, 삼각 함수 등

##### 5.2.1 산술 연산자
- 피연산자가 숫자인 연산자
- 모든 산술 연산은 64비트 부동 소수점 연산
```
7/2             //-> 3.5 (정수끼리 나눌 때)
5%1.5          //->3 (부호는 앞의 수와 같다)
1+“2month”  //-> 12month, +연산자는 피연산자가 숫자면 더하고 문자열이면 연결한다.
0/0            //-> NaN : 계산할 수 없음
“one”*1     //-> NaN : 계산 할 수 없음
true + true    //-> 2 : 논리값의 타입을 숫자로 바꾸어 더함
1+null         //-> 1 : null을 0으로 바꾸어 더함
1+undefined   //-> NaN : undefined를 NaN으로 바꾸어 더함
```
- 산술 단항 연산자 : 피 연산자는 좌변(대입 연산자 왼쪽에 둘 수 있는 표현식)에 있어야 한다.
- 증가 연산자 ++a : a에 1을 더한 다음에 a 값을 평가한다.
- 증가 연산자 a++ : a를 평가한 다음에 a에 1을 더한다.
- 감소 연산자 –-a : a에 1을 뺀 다음에 a 값을 평가한다.
- 감소 연산자 a-- : a를 평가한 다음에 a에 1을 뺀다.
- 아무것도 처리하지 않음 +a : a와 같은 값으로 평가한다.
- 부호 반전 –a : a의 부호를 반전한 값으로 평가한다.
```
a = 1;
b = ++a;  //-> b=2, a=2
c = a++ + 2;  //-> c=4, a=3
(a++)++ // ReferenceError 연산자 연속 사용 시 참조오류
```

- 산술 대입 연산자
- a += b : a = a+b
- a -= b : a = a-b
- a *= b : a = a*b
- a /= b : a = a/b
- a %= b : a = a%b

##### 5.2.2 Math 객체의 프로퍼티
```
function polarToDescartes(r, theta){
	var angle = Math.PI*theta/180;
	return {x : r*Math.cos(angle), y : r*Math.sin(angle)};
}
```
- Math 객체의 메서드 : p136-137

##### 5.2.3 부동소수점과 정확도 문제
- 자바 스크립트 숫자는 IEEE754로 규정된 64비트 부동소수점
- 1비트, 11비트, 52비트 = 부호, 지수, 가수
- 간단한 뺄셈에서도 유효 자릿수가 변경돼서 수학적 계산 값과 다르다.
```
Math.sqrt(100001)-Math.sqrt(100000) = 0.001581134877255863  // js
Math.sqrt(100001)-Math.sqrt(100000) = 0.001581134877256878...  // 수학적계산
```
- 정밀도 손실을 피하려면 크기가 비슷한 수의 뺄셈을 피하도록 해야 한다.
```
1/Math.sqrt(100001)-Math.sqrt(100000) // 정밀도 손실을 피하는 방법
```
- 10진수로 딱 떨어지는 값도 계산 결과가 어긋난다. 산술 연산을 내부적으로는 2진수로 연산
```
a=0.16, b=0.2
a/b //-> 0.7999999999999999
a/b ==0.8  //-> false
Math.abs(a/b-0.8)<1e-10 // 문제를 피하는 방법(abs : 절댓값)
```

### 5.3 문자열 제어하기

##### 5.3.1 문자열 연결
- +연산자는 피연산자가 모두 문자열이면 문자열로 연결한다.
```
“Hello” + “World”  // -> “Hello World”
“1” + “2”  //　->“12”
```
- 피연산자 중 하나가 문자열 또는 문자열로 변환할 수 있는 객체라면 다른 피연산자의 타입을 문자열로 바꾼 다음 연결
```
10 + “ little indians”  //-> “10 little indians”
1 + {}  //-> “ 1[object Object]”
true + (new Date())  //-> “trueTue Sat Aug 05 2019 22:38:59 GMT+0900(KST)”
```

##### 5.3.2 문자열을 조작하는 메서드
- 래핑 : 원시 값을 객체로 변환하는 행위
- String 객체의 주요 메서드 : q.140-141
```
var msgObj = new String(“Everything is practice.”); 
msgObj.length  //-> 23(순서는 왼쪽부터 0, 1, 2, 3...)
msgObj.charAt(3) //-> “r”(charAt :대상 문자열의 n번째 문자)
```
- 문자열은 객체가 아니므로 프로퍼티를 가지고 있지 않지만 문자열에서 프로퍼티를 사용하려고 하면 문자열이 자동으로 String 객체로 변환된다.
- 래퍼 객체(ex.msgObj) : 실행하는 순간에 일시적으로 생성되는 String 객체이므로 사용자에게는 보이지 않는다. 처리가 끝나면 곧바로 메모리에서 삭제
- 원시 값을 처리할 때 원시 값을 래퍼 객체로 자동 변환
- 문자열은 String, 숫자는 Number, 논리값은 Boolean 객체로 변환
- null과 undefined에는 래퍼객체가 없다.
```
var msg = “Everything is practice.”;
console.log(msg.length);  //->23
console.log(msg.charAt(3));  //->r

var c = msg.charAt(3) //-> 코드 실행시 아래 작업 실행
var msgObj = new String(msg) // 문자열을 String 객체로 변환
var c = msgObj.charAt(3) // String 객체의 메서드를 사용
```
- 원시 값을 처리할 때는 대부분 msg.charAt(3)처럼 원시 값의 메서드를 바로 호출하며, String 객체 등으로 다시 변환해서 처리하지는 않는다. 왜냐하면 String 객체는 원시 값이 아니라 객체이기 때문에 원시 값이 들어올 것으로 가정하고 작성한 코드에 String 객체를 섞어서 사용하면 오류가 발생하는 원이이 될 수 있다.
```
var msg = “Everything is practice.”;
console.log(msg)  //-> Everything is practice.

var msg = new String(“Everything is practice.”);
console.log(msg) //-> String {[[PrimitiveValue]] : “Everything is practice.”}

var msg = new String(“Everything is practice.”).valueOf(); // String  객체를 다시 문자열로 바꿔줌
console.log(msg) //-> Everything is practice.
```
- 문자열 메서드를 사용한 예
```
p.143
```
- 자바스크립트의 문자열은 불변
- replace와 toUpperCae 메서드 등은 새로운 문자열을 반환하며 메서드를 호출한 문자열은 수정하지 않습니다.
- 또한 codePointAt메서드는 써로게이트 페어를 지원합니다. 

##### 5.3.3 String 생성자의 메서드
- 자바스크립트의 함수는 객체이며 프로퍼티를 갖고 있다.
- String 생성자 또한 일종의 함수이며 프로퍼티를 갖고 있다.
```
String.length //->1
```
- String.fromCharcode 메서드는 문자 코드(UTF-16 인코딩 값)를 문자열로 변환한다.
```
String.fromCharCode(0xAE38)  //-> 길
String.fromCharCode(65, 66, 67)  //->“ABC”
String.fromCharCode(0xd83d, 0xdcd6) //-> ☏(책아이콘) 써로게이트 페어 문자
String.fromCharCode(0x1f4d6) //-> “□ ”써로게이트 페어의 다섯 자릿수 코드 포인트 표현은 지원하지 않는다.
String.fromCodePoint(0x1f4d6) //-> ☏ 써로게이트 페어의 코드 포인트 스칼라 값을 인수로 넘겨도 올바른 값을 반환(ES60부터 추가된 String.fromCharCode 메서드는 UTP-16의 부호 값과 유니코드 코드 포인트 스칼라 값을 모두 지원한다.)
“＼u{1f4d6}” // ES6부터 추가된 유니코드 리터럴
```

##### 5.3.4 문자열을 배열로 읽고 쓰기
- 문자열을 읽을 때는 charAt 메서드 대신 대괄호 연사자를 사용할 수 있다.
```
msg[3]     //-> “r”
msg[msg.length-1]   //-> “.”
```
- 배열처럼 값을 대입해서 수정할 수는 없다.
```
msg[3] = “R”;
console.log(msg);  //-> Everything is practice.
```
- 써로 게이트 페어로 표현하는 문자는 두 개의 배열 요소로 분리한다.
```
var s = “☏”;
s.codePointAt(0).toString(16)      //-> “1f4d6” : 코드 포인트의 스칼라 값
s[0].codePointAt(0).toString(16)   //-> “d83d” : 상위 써로게이트
s[1].codePointAt(0).toString(16)   //-> “dcd6” : 하위 써로게이트
s[0]+s[1]    //-> “☏”
```
Note. 써로게이트 페어
유니코드는 문자 집합과 문자 인코딩 방식을 정한 표준 문자 코드이며 유니코드 문자 집합에는 전 세계에서 사용하는 문자가 포함되어 있다. 스칼라 값은 코드 포인트 값이라고도 부르며 U+8A9E처럼 앞에 U+를 붙인 16진수로 표현합니다. 이러한 유니코드 인코딩 방식에는 UTF-8, UTF-16, UTF-32 등이 있다.

### 5.4 논리 연산자와 관계 연산자
- 논리식은 프로그램의 로직을 표현하기 위한 기본적인 수단
##### 5.4.1 관계 연산자
- 두 개의 피연산자를 비교한 결과를 논리값으로 반환한다.
- 주로 조건식을 만들 때 사용
- a==b : a 값과 b 값이 같으면 true, 그 외에는 false  
a!=b : a 값과 b 값이 다르면 true, 그 외에는 false  
a===b : a와 b의 값과 타입이 같으면 true, 그 외에는 false  
a!==b : a와 b의 값과 타입이 다르면 true, 그 외에는 false  
```
var a = [1, 2, 3];
var b = [1, 2, 3];
var c = a;
console.log(a==b); //-> fals(같은 데이터가 담겨있지만 메모리에서 차지하는 위치가 다름)
console.log(a==c); //-> true
```
```
null==undefined //-> true : undefined와 null은 같은 것으로 친다.
1 == “1”//-> true : 한쪽이 숫자고 다른 한쪽이 문자열이면 문자열을 숫자로 변환해서 비교
“0xff” == 255  //-> true
true == 1 //-> true : 둘 중에 한쪽이 논리값이면 true는 1, false는 0으로 변환해서 비교
true == “1” //-> true 
(new String(“a”)) == “a”//-> true : 한쪽이 객체고 다른 한쪽이 숫자 또는 문자열이면 객체를 toString이나 valueOf 메서드를 사용해서 원시 타입으로 변환한 다음에 비교
(ner Number(2)) == 2 //-> true
[2] == 2 //-> true
// 앞의 규칙에서 벗어나면 모두 ‘같지 않음’
```
- 일치 연산자 (===) : 피연산자를 평가한 후에 타입을 변환하지 않은 상태의 두 값을 엄격하게 비교
```
NaN === NaN //->false, NaN은 x!==x를 만족하는 유일한 값
null==undefined //-> false
1 == “1”//-> false
“0xff” == 255  //-> false
true == 1 //-> false
true == “1” //-> false
(new String(“a”)) == “a”//-> false
(ner Number(2)) == 2 //-> false
[2] == 2 //-> false
```

##### 5.4.2 논리 연산자
- a&&a : a와 b가 모두 true면 true, 그 외에는 false    
a||a : a와 b 중 하나라도 true면 true, 모두가 false면 false
!a : a가 true면 false, false면 true
- 관계 연산자의 우선순위가 논리 연산자보다 높다.(괄호 쓸 필요 없음)
-  !가 &&보다 우선순위가 높다.
```
x>0 && y>0  // x와 y가 모두 참일 때만 true
x>0 || y>0 // x와 y중 하나라도 참이면 true, 모두가 0이하면 false
!(a&&b) // a또는 b가 거짓
```
- 피연산자의 평가 : 피연산자가 논리값이 아니면 필요에 따라 타입 변환
- 0, -0, 빈 문자열(“”), NaN, null, undefined : false
- 0을 제외한 숫자, 빈 문자열을 제외한 문자열, 모든 객체, 심벌 : true
- 논리곱 연산자와 논리합 연산자의 단락평가
- 단락평가 : 첫 번째 피연산자 값이 표현식을 결정하면 두 번째 피연산자를 평가하지 않는 것
```
var p = null;
p && p.name //->null : p가 false로 평가되므로 p를 반환, p.name을 평가하지 않으므로 오류가 발생하지 않음
p = { name :“Tom”, age : 18};
p && p.name //->“Tom”: p가 true로 평가 되므로 p.name을 반환
```
- || 연산자는 여러 개의 값 후보 중에서 null 또는 undefined가 아닌 값을 선택하고자 할 때 사용
- 이렇게 작성해도 논리값이 필요한 장소에서는 논리값으로 타입이 변환
```
var time = time_interval || animationSettings.time || 33; // time_interval 정의 시 time_interval 값 사용, 정의되지 않았을 시 animationSettings.time 사용, 이 또한 정의되지 않았을 시 33 사용
```
```
function f(x) {
	x = x || 100;
	...
}
f()/ 인수 없이 호출 시 x에는 undefined ->false
x = x || 100; //->100

f(2)
x = x || 100 //->2
```
- 이 방법에서 0, “”등 false로 평가되는 값을 넘기면 그 값이 사용되지 않고 초깃값(앞의코드에서는 100)이 그대로 사용된다.

### 5.5 비트 연산
- 데이터 통신이나 이진 파일을 처리할 때 자주 사용

##### 5.5.1 비트 연산
- 피연산자를 부호 있는 32비트 정수로 변환 후 처리
- 첫 번째 비트는 부호
- a = 105 = 01101001(2)  
b = -91 = 10100101(2)

##### 5.5.2 비트 논리 연산자
- 비트 값이 0이면 false, 1이면 true
- & : 비트 논리곱(AND)
- | : 비트 논리합(OR)
- ^ : 비트 배타적 논리합(XOR)
- ~ : 비트 논리 부정(NOT)
```
105 & (-91) // -> 33 = 00100001
105 | (-91) //-> -19 = 11101101
105 ^(-91) //-> -52 = 11001100
~105 //-> -106 = 10010110(자바스크립트 에서는 음의 정수를 보수를 사용해서 a의 보수는 ~a+1로 표현
```

##### 5.5.3 비트 시프트 연산자
- 정수를 2진수 비트 단위로 오른쪽 또는 왼쪽으로 이동시키는 연산자
- << : 왼쪽 시프트
- >> : 부호 있는 오른쪽 시프트
- >>> : 부호 없는 오른쪽 시프트
```
105<<3 //-> 804
91>>3  //-> -12
93>>>3  //-> 536870900
//p. 155
```
##### 5.5.4 비트 연산자의 대입 연산자
- a &= b : a = a & b
- a |= b : a = a | b
- a ^= b : a = a^b
- a <<= n : a = a<<n
- a >>= n : a = a>>n
- a >>>=n : a = a>>>n


### 5.6 기타연산
- typeof : 데이터 타입을 조사한다.
- ?: 조건 연산자
- void : 정의되지 않은 값을 반환한다.
- , : 왼쪽에서 오른쪽 순서대로 피연산자를 연속해서 실행한다. 
- delete : 객체의 프로퍼티나 배열 요소를 제거한다.
- new : 새로운 객체를 생성한다.
- in : 객체의 프로퍼티 포함 여부를 확인한다.
- instanceof : 객체의 종류를 확인한다.
- eval : 인수로 받은 문자열을 자바스크립트 코드로 실행한다.

##### 5.6.1 typeof 연산자
- 단항 연산자이며 피연사자의 데이터 타입을 뜻하는 문자열을 반환
```
var s = “ABC”
console.log(typeof s);  //-> string(문자열)
```
- 숫자, NaN(ex. 12, 3.14, NaN) : “number”
- 문자열(ex. “abc”, “안녕하세요”) : “string”
- 논리값(ex. true, false) : “ boolean”
- 정의되지 않은 값(ex. undefined) : “undefined”
- null 값(ex. null) : “object”
- 심벌 (ex. Symbol(“heart”)) : “Symbol”
- 함수 외의 객체(ex. [1,2,3], String(“abc”), Number(1) : “object”
- 함수(ex. function(x) {return ++x;} : “function”

##### 5.6.2 조건 연산자
- 주어진 조건의 참과 거짓에 따라 값을 선택
```
var parity = (a%2==0)? “짝수” : “홀수”; // a가 짝수이면 “짝수”이고 나머지는 “홀수”
/* if/else문 */
if(a % 2 == 0) {
	parity = “짝수”;
}else{
	parity = “홀수”;
}
var a=2;
console.log(parity); //-> 홀수
```

##### 5.6.3 쉼표 연산자
- 이항 연산자로 왼쪽 피연산자를 평가하고 오른쪽 피연산자를 평가한 이후에 마지막으로 오른쪽 끝 피연산자의 값을 반환한다.
```
i = 0, sum = 0, product = 1;  //-> i = 0; sum = 0; product = 1;

/* for문 */
for(var i = 1, sum = 0; i<=10; I++){
	sum += i;
} // for 문의 소괄호 안에는 문장을 세 개만 넣을 수 있지만, 이 예제에서는 쉼표 연산자를 사용하여 더 많은 문장을 실행할 수 있다.
```

##### 5.6.4 eval 함수
- 함수지만 연산자의 역할을 담당
- 문자열 단 하나만을 인수로 받아서 자바스크립트 코드로 해석
- 문자열을 해석할 때는 코드를 평가한 후에 마지막 표현식 또는 문장의 값을 반환
- 문자열을 해석할 수 없을 때는 문법 오류 발생
- eval 함수를 호출한 환경의 유효범위 안에 있는 변수를 사용, 일반 함수처럼 함수 유효 범위를 만들지 않는다는 점을 유의
- eval 함수를 호출하는 행위는 인수로 받은 문자열을 코드로 바꾸어 eval 함수를 호출한 부분과 맞바꾸겠다는 뜻
```
var x = 1;
eval(“x++;”);
//=
var x = 1;
x++;
/* 문자열로 함수 선언문을 넘겨서 함수 정의 */
var formula = “x*x”;
eval(“function f(x) {return”+ formula + “;}”);
// =
functions f(x) {return x*x;}; 
```
- eval 함수는 사용자가 악의적으로 입력한 문자열을 eval 함수에 인수로 넘기면 악성 코드가 실행되어 보안 문제가 생길 수 있다.
- eval 함수로 실행한 코드는 속도가 느리다.

### 5.7 명시적 타입 변환

##### 5.7.1 숫자를 문자열로 변환하기
- 숫자+문자열 : 숫자의 타입이 문자열로 바뀐다.
```
10+ “cookies”//-> “10cookies:
100+ “” //-> “100” : 빈 문자열을 더해 숫자 타입을 문자열로 바꿈
(“0000”=12).slice(-4)  //-> “0012”
```
- Number 객체의 메서드를 활용하는 방법
```
var n = 26;
n.toString()  //->“26” : 인수를 지정하지 않으면 10진수 문자열로 변환
n.toString(2)  //-> “11010” : 2진수 문자열로 변환
n.toString(16)  //-> “1a” : 16진수 문자열로 변환
(26).toString(16)  //-> “1a”: 숫자에서 바로 메서드를 사용하고자 할 때 

var x = 1234.567;
x.toStirng()   //->“1234.567”
x.toString(16)  //-> “4d2.9126e978d5”
x.toFixed(0)  //-> “1235” : 소수점 아래 자릿수를 지정한 문자열로 변환
x.toFixed(2)  //-> “1234.57”
x.toFixed(6)  //-> “1234.5670”
x.toExponential(3)  //-> “1.235e+3”:　소수점 아래 자릿수를 지정한 문자열로 변환하되 지수를 함께 표시
x.toPrecision(3)  //-> “1.23e+3” :　숫자를 유효 숫자가 지정된 문자열로 변환한다. 단, 유효 숫자가 정수부의 자릿수보다 작을 때는 지수로 표시
```
- String 함수를 활용하는 방법
- new String은 객체를 생성하는 함수, String은 일반적인 함수
```
String(26)  //-> “26”: 반환값은 문자열
String(1234.567)  //-> “1234.567”
String(0x1a)  //-> “26”
String(“ABC”)  //-> “ABC”
String(true)  //-> “ true”
String(false)  //-> “false”
String(NaN)  //-> “NaN”
String(null)  //-> “null”
String(undifined)  //-> “undifined”
String({x:1, y:2})  //-> “[object object]”
String([1, 2, 3])  //-> “1, 2, 3”
```
##### 5.7.2 문자열을 숫자로 변환하기
- 수식 안에서 묵시적으로 변환하는 방법
```
var s = “2”;
s-0  //-> 2
+s  //-> 2
```
- parseInt와 parseFloat 함수를 사용하는 방법
- 문자열을 해석해서 숫자로 바꾸는 함수
```
parseInt(“3.14”)  //-> 3 : 문자열을 정수로 바꿈
parseFloat(“3.14”)  //-> 3.14 : 문자열을 부동소수점으로 바꿈
parseInt(“3.14 meters”) //-> 3 : 숫자 다음에 등장하는 문자열은 무시
parseFloat(“3.14 meters”)  //-> 3.14 : 숫자 다음에 등장하는 문자열은 무시
parseInt(“0xFF”)  //-> 255 : 0x로 16진수 해석
parseInt(“0.5”)  //-> 0
parseInt(“.5”)  //-> NaN : . 이 있으므로 해석하지 않음
parseInt(“abc”)  //-> NaN : 숫자로 해석할 수 없음
parseFloat(“\100”)  //-> NaN : \ 이 있으므로 해석하지 않음
parseInt(“101”,2)  //-> 5 : 문자열을 2진수로 해석해서 변환
parseInt(“ff”, 16)  //-> 255 : 문자열을 16진수로 해석해서 변환
```
- Number 함수를 활용하는 방법
- new Number은 객체를 생성하는 함수, Number은 일반적인 함수
```
Number(“2.71828”)  //-> 2.71828 : 반환값은 숫자
Number(123) //-> 123 : 모든 데이터 값을 숫자 타입으로 바꿈
Number(true) //-> 1
Number(false) //-> 0
Number(NaN) //-> NaN
Number(undefined) //-> NaN
Number(null) //-> 0
Number({x:1, y:2}) //-> NaN
Number([1, 2, 3]) //-> NaN
```

##### 5.7.3 논리값으로 변환하기
```
!!x  //-> 앞의 ! : 논리 타입으로 바꿈, 뒤의 ! : 부정
Boolean(x)
```
