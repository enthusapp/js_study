### 연산자
##### 연산자 우선순위, 결합법칙
산술 연산 방식 vs 계산기 연산 방식

##### 부수 효과(side effect)
대입, 증가, 감소 delete 연산자 &rarr; 원본을 변경

부수 효과 없는 함수 &rarr; 사본을 만들어 대입

### 산술 연산
사용할때 이해하고 찾아보는 것이 중요

### 문자열 제어하기
문자열은 객체가 아니지만 사용할때는 자동으로 String 객체로 변환됨, 코드와 문자,
문자열은 불변 새로운 문자열을 반환하지만 이전 문자열은 수정X


### 5.1 연산자 
ex. +, *

##### 5.1.1 표현식과 연산자
```
a + b
```
- a와 b부분은 연상 대상이 되는 표현식(피연산자)
표현식은, 숫자, 문자열, 논리값, 변수, 프로퍼티, 배열 요소, 함수 호출, 메서드호출 이 될 수도 있다.
- 피 연산자의 개수에 따라 단항 연산자, 이항 연산자, 삼항 연산자로 분류
- 삼항 연산자는 ?:(a?b:c = a가 참이면 b로 평가되고 그 밖에는 c로 평가된다.)
- 표현식은 먼저 왼쪽 피연산자 값부터 순서대로 평가되고, 그 다음에 연산자로 계산 시작
- 예외 연산자 : ||, &&, ?:(연산자 먼저 평가)

##### 5.1.2 연산자의 우선순위
- () 안에 들어있는 표현식이 가장 먼저 평가
- * -> +
```
(24/6)*2 //-> 8
24/(6*2)  //-> 2
```

##### 5.1.3 연산자 결합 법칙
- 나눗셈 연산자, 곱셈 연산자는 우선순위는 같지만 왼쪽에서 오른쪽으로 결합
- p. 130 연산자의 우선순위와 결합법칙
```
24/6*2  //-> 8
```

##### 5.1.4 연산자의 부수 효과
```
x=y
```
- 변수 값을 바꾸는 표현식은 일반적으로 부수 효과가 있는 표현식이라고 한다.
- 대입 연산자, 증가 연산자, 감소 연산자, delete


### 5.2 산술 연산
- 사칙연산, 나머지 값, 제곱근, 삼각 함수 등

##### 5.2.1 산술 연산자
- 피연산자가 숫자인 연산자
- 모든 산술 연산은 64비트 부동 소수점 연산
```
7/2             //-> 3.5 (정수끼리 나눌 때)
5%1.5          //->3 (부호는 앞의 수와 같다)
1+“2month”  //-> 12month, +연산자는 피연산자가 숫자면 더하고 문자열이면 연결한다.
0/0            //-> NaN : 계산할 수 없음
“one”*1     //-> NaN : 계산 할 수 없음
true + true    //-> 2 : 논리값의 타입을 숫자로 바꾸어 더함
1+null         //-> 1 : null을 0으로 바꾸어 더함
1+undefined   //-> NaN : undefined를 NaN으로 바꾸어 더함
```
- 산술 단항 연산자 : 피 연산자는 좌변(대입 연산자 왼쪽에 둘 수 있는 표현식)에 있어야 한다.
- 증가 연산자 ++a : a에 1을 더한 다음에 a 값을 평가한다.
- 증가 연산자 a++ : a를 평가한 다음에 a에 1을 더한다.
- 감소 연산자 –-a : a에 1을 뺀 다음에 a 값을 평가한다.
- 감소 연산자 a-- : a를 평가한 다음에 a에 1을 뺀다.
- 아무것도 처리하지 않음 +a : a와 같은 값으로 평가한다.
- 부호 반전 –a : a의 부호를 반전한 값으로 평가한다.
```
a = 1;
b = ++a;  //-> b=2, a=2
c = a++ + 2;  //-> c=4, a=3
(a++)++ // ReferenceError 연산자 연속 사용 시 참조오류
```

- 산술 대입 연산자
- a += b : a = a+b
- a -= b : a = a-b
- a *= b : a = a*b
- a /= b : a = a/b
- a %= b : a = a%b

##### 5.2.2 Math 객체의 프로퍼티
```
function polarToDescartes(r, theta){
	var angle = Math.PI*theta/180;
	return {x : r*Math.cos(angle), y : r*Math.sin(angle)};
}
```
- Math 객체의 메서드 : p136-137

##### 5.2.3 부동소수점과 정확도 문제
- 자바 스크립트 숫자는 IEEE754로 규정된 64비트 부동소수점
- 1비트, 11비트, 52비트 = 부호, 지수, 가수
- 간단한 뺄셈에서도 유효 자릿수가 변경돼서 수학적 계산 값과 다르다.
```
Math.sqrt(100001)-Math.sqrt(100000) = 0.001581134877255863  // js
Math.sqrt(100001)-Math.sqrt(100000) = 0.001581134877256878...  // 수학적계산
```
- 정밀도 손실을 피하려면 크기가 비슷한 수의 뺄셈을 피하도록 해야 한다.
```
1/Math.sqrt(100001)-Math.sqrt(100000) // 정밀도 손실을 피하는 방법
```
- 10진수로 딱 떨어지는 값도 계산 결과가 어긋난다. 산술 연산을 내부적으로는 2진수로 연산
```
a=0.16, b=0.2
a/b //-> 0.7999999999999999
a/b ==0.8  //-> false
Math.abs(a/b-0.8)<1e-10 // 문제를 피하는 방법(abs : 절댓값)
```

### 5.3 문자열 제어하기

##### 5.3.1 문자열 연결
- +연산자는 피연산자가 모두 문자열이면 문자열로 연결한다.
```
“Hello” + “World”  // -> “Hello World”
“1” + “2”  //　->“12”
```
- 피연산자 중 하나가 문자열 또는 문자열로 변환할 수 있는 객체라면 다른 피연산자의 타입을 문자열로 바꾼 다음 연결
```
10 + “ little indians”  //-> “10 little indians”
1 + {}  //-> “ 1[object Object]”
true + (new Date())  //-> “trueTue Sat Aug 05 2019 22:38:59 GMT+0900(KST)”
```

##### 5.3.2 문자열을 조작하는 메서드
- 래핑 : 원시 값을 객체로 변환하는 행위
- String 객체의 주요 메서드 : q.140-141
```
var msgObj = new String(“Everything is practice.”); 
msgObj.length  //-> 23(순서는 왼쪽부터 0, 1, 2, 3...)
msgObj.charAt(3) //-> “r”(charAt :대상 문자열의 n번째 문자)
```
- 문자열은 객체가 아니므로 프로퍼티를 가지고 있지 않지만 문자열에서 프로퍼티를 사용하려고 하면 문자열이 자동으로 String 객체로 변환된다.
- 래퍼 객체(ex.msgObj) : 실행하는 순간에 일시적으로 생성되는 String 객체이므로 사용자에게는 보이지 않는다. 처리가 끝나면 곧바로 메모리에서 삭제
- 원시 값을 처리할 때 원시 값을 래퍼 객체로 자동 변환
- 문자열은 String, 숫자는 Number, 논리값은 Boolean 객체로 변환
- null과 undefined에는 래퍼객체가 없다.
```
var msg = “Everything is practice.”;
console.log(msg.length);  //->23
console.log(msg.charAt(3));  //->r

var c = msg.charAt(3) //-> 코드 실행시 아래 작업 실행
var msgObj = new String(msg) // 문자열을 String 객체로 변환
var c = msgObj.charAt(3) // String 객체의 메서드를 사용
```
- 원시 값을 처리할 때는 대부분 msg.charAt(3)처럼 원시 값의 메서드를 바로 호출하며, String 객체 등으로 다시 변환해서 처리하지는 않는다. 왜냐하면 String 객체는 원시 값이 아니라 객체이기 때문에 원시 값이 들어올 것으로 가정하고 작성한 코드에 String 객체를 섞어서 사용하면 오류가 발생하는 원이이 될 수 있다.
```
var msg = “Everything is practice.”;
console.log(msg)  //-> Everything is practice.

var msg = new String(“Everything is practice.”);
console.log(msg) //-> String {[[PrimitiveValue]] : “Everything is practice.”}

var msg = new String(“Everything is practice.”).valueOf(); // String  객체를 다시 문자열로 바꿔줌
console.log(msg) //-> Everything is practice.
```
- 문자열 메서드를 사용한 예
```
p.143
```
- 자바스크립트의 문자열은 불변
- replace와 toUpperCae 메서드 등은 새로운 문자열을 반환하며 메서드를 호출한 문자열은 수정하지 않습니다.
- 또한 codePointAt메서드는 써로게이트 페어를 지원합니다. 

##### 5.3.3 String 생성자의 메서드
- 자바스크립트의 함수는 객체이며 프로퍼티를 갖고 있다.
- String 생성자 또한 일종의 함수이며 프로퍼티를 갖고 있다.
```
String.length //->1
```
- String.fromCharcode 메서드는 문자 코드(UTF-16 인코딩 값)를 문자열로 변환한다.
```
String.fromCharCode(0xAE38)  //-> 길
String.fromCharCode(65, 66, 67)  //->“ABC”
String.fromCharCode(0xd83d, 0xdcd6) //-> ☏(책아이콘) 써로게이트 페어 문자
String.fromCharCode(0x1f4d6) //-> “□ ”써로게이트 페어의 다섯 자릿수 코드 포인트 표현은 지원하지 않는다.
String.fromCodePoint(0x1f4d6) //-> ☏ 써로게이트 페어의 코드 포인트 스칼라 값을 인수로 넘겨도 올바른 값을 반환(ES60부터 추가된 String.fromCharCode 메서드는 UTP-16의 부호 값과 유니코드 코드 포인트 스칼라 값을 모두 지원한다.)
“＼u{1f4d6}” // ES6부터 추가된 유니코드 리터럴
```

##### 5.3.4 문자열을 배열로 읽고 쓰기
- 문자열을 읽을 때는 charAt 메서드 대신 대괄호 연사자를 사용할 수 있다.
```
msg[3]     //-> “r”
msg[msg.length-1]   //-> “.”
```
- 배열처럼 값을 대입해서 수정할 수는 없다.
```
msg[3] = “R”;
console.log(msg);  //-> Everything is practice.
```
- 써로 게이트 페어로 표현하는 문자는 두 개의 배열 요소로 분리한다.
```
var s = “☏”;
s.codePointAt(0).toString(16)      //-> “1f4d6” : 코드 포인트의 스칼라 값
s[0].codePointAt(0).toString(16)   //-> “d83d” : 상위 써로게이트
s[1].codePointAt(0).toString(16)   //-> “dcd6” : 하위 써로게이트
s[0]+s[1]    //-> “☏”
```
Note. 써로게이트 페어
유니코드는 문자 집합과 문자 인코딩 방식을 정한 표준 문자 코드이며 유니코드 문자 집합에는 전 세계에서 사용하는 문자가 포함되어 있다. 스칼라 값은 코드 포인트 값이라고도 부르며 U+8A9E처럼 앞에 U+를 붙인 16진수로 표현합니다. 이러한 유니코드 인코딩 방식에는 UTF-8, UTF-16, UTF-32 등이 있다.
