### 연산자
##### 연산자 우선순위, 결합법칙
산술 연산 방식 vs 계산기 연산 방식

##### 부수 효과(side effect)
대입, 증가, 감소 delete 연산자 &rarr; 원본을 변경

부수 효과 없는 함수 &rarr; 사본을 만들어 대입

### 산술 연산
사용할때 이해하고 찾아보는 것이 중요

### 문자열 제어하기
문자열은 객체가 아니지만 사용할때는 자동으로 String 객체로 변환됨, 코드와 문자,
문자열은 불변 새로운 문자열을 반환하지만 이전 문자열은 수정X


### 5.1 연산자 
ex. +, *

##### 5.1.1 표현식과 연산자
```
a + b
```
- a와 b부분은 연상 대상이 되는 표현식(피연산자)
- 표현식은, 숫자, 문자열, 논리값, 변수, 프로퍼티, 배열 요소, 함수 호출, 메서드호출 이 될 수도 있다.
- 피 연산자의 개수에 따라 단항 연산자, 이항 연산자, 삼항 연산자로 분류
- 삼항 연산자는 ?:(a?b:c = a가 참이면 b로 평가되고 그 밖에는 c로 평가된다.)
- 표현식은 먼저 왼쪽 피연산자 값부터 순서대로 평가되고, 그 다음에 연산자로 계산 시작
- 예외 연산자 : ||, &&, ?:(연산자 먼저 평가)

##### 5.1.2 연산자의 우선순위
- () 안에 들어있는 표현식이 가장 먼저 평가
- * -> +
```
(24/6)*2 //-> 8
24/(6*2)  //-> 2
```

##### 5.1.3 연산자 결합 법칙
- 나눗셈 연산자, 곱셈 연산자는 우선순위는 같지만 왼쪽에서 오른쪽으로 결합
- p. 130 연산자의 우선순위와 결합법칙
```
24/6*2  //-> 8
```

##### 5.1.4 연산자의 부수 효과
```
x=y
```
- 변수 값을 바꾸는 표현식은 일반적으로 부수 효과가 있는 표현식이라고 한다.
- 대입 연산자, 증가 연산자, 감소 연산자, delete


### 5.2 산술 연산
- 사칙연산, 나머지 값, 제곱근, 삼각 함수 등

##### 5.2.1 산술 연산자
- 피연산자가 숫자인 연산자
- 모든 산술 연산은 64비트 부동 소수점 연산
```
7/2             //-> 3.5 (정수끼리 나눌 때)
5%1.5          //->3 (부호는 앞의 수와 같다)
1+“2month”  //-> 12month, +연산자는 피연산자가 숫자면 더하고 문자열이면 연결한다.
0/0            //-> NaN : 계산할 수 없음
“one”*1     //-> NaN : 계산 할 수 없음
true + true    //-> 2 : 논리값의 타입을 숫자로 바꾸어 더함
1+null         //-> 1 : null을 0으로 바꾸어 더함
1+undefined   //-> NaN : undefined를 NaN으로 바꾸어 더함
```
- 산술 단항 연산자 : 피 연산자는 좌변(대입 연산자 왼쪽에 둘 수 있는 표현식)에 있어야 한다.
- 증가 연산자 ++a : a에 1을 더한 다음에 a 값을 평가한다.
- 증가 연산자 a++ : a를 평가한 다음에 a에 1을 더한다.
- 감소 연산자 –-a : a에 1을 뺀 다음에 a 값을 평가한다.
- 감소 연산자 a-- : a를 평가한 다음에 a에 1을 뺀다.
- 아무것도 처리하지 않음 +a : a와 같은 값으로 평가한다.
- 부호 반전 –a : a의 부호를 반전한 값으로 평가한다.
```
a = 1;
b = ++a;  //-> b=2, a=2
c = a++ + 2;  //-> c=4, a=3
(a++)++ // ReferenceError 연산자 연속 사용 시 참조오류
```

- 산술 대입 연산자
- a += b : a = a+b
- a -= b : a = a-b
- a *= b : a = a*b
- a /= b : a = a/b
- a %= b : a = a%b

##### 5.2.2 Math 객체의 프로퍼티
```
function polarToDescartes(r, theta){
	var angle = Math.PI*theta/180;
	return {x : r*Math.cos(angle), y : r*Math.sin(angle)};
}
```
- Math 객체의 메서드 : p136-137

##### 5.2.3 부동소수점과 정확도 문제
- 자바 스크립트 숫자는 IEEE754로 규정된 64비트 부동소수점
- 1비트, 11비트, 52비트 = 부호, 지수, 가수
- 간단한 뺄셈에서도 유효 자릿수가 변경돼서 수학적 계산 값과 다르다.
```
Math.sqrt(100001)-Math.sqrt(100000) = 0.001581134877255863  // js
Math.sqrt(100001)-Math.sqrt(100000) = 0.001581134877256878...  // 수학적계산
```
- 정밀도 손실을 피하려면 크기가 비슷한 수의 뺄셈을 피하도록 해야 한다.
```
1/Math.sqrt(100001)-Math.sqrt(100000) // 정밀도 손실을 피하는 방법
```
- 10진수로 딱 떨어지는 값도 계산 결과가 어긋난다. 산술 연산을 내부적으로는 2진수로 연산
```
a=0.16, b=0.2
a/b //-> 0.7999999999999999
a/b ==0.8  //-> false
Math.abs(a/b-0.8)<1e-10 // 문제를 피하는 방법(abs : 절댓값)
```
